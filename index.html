  <!DOCTYPE html>
  <html>

  <head>
    <script
      src="https://cdn.jsdelivr.net/gh/aframevr/aframe@f322d237cb6be356661a2334dfdf7459da6885c4/dist/aframe-master.min.js"></script>
    <script src="https://www.WebRTC-Experiment.com/RecordRTC.js"></script>
      <script src="https://unpkg.com/aframe-extras/dist/aframe-extras.min.js"></script>
    <script src="anchor-grabbed-entity.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/1.6.2/axios.min.js"
      integrity="sha512-b94Z6431JyXY14iSXwgzeZurHHRNkLt9d6bAHt7BZT38eqV+GyngIi/tVye4jBKPYQ2lBdRs0glww4fmpuLRwA=="
      crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
      var questionLine = "Grab Mic To Talk"
      var answerLine = "Release The Mic When You Done Recording"
    </script>
    <script>window.activeGrabbingHand = null;</script>
    <script>
      let isRecordingInProgress = false;

      const SERVER_URL = window.location.origin.includes("localhost")
        ? "http://localhost:5000"
        : "https://holonext-ai-asistant.onrender.com";

      async function processAudio(recordingBlob) {
        console.log("Processing audio...");
        updateText('Processing Your Record');

        const formData = new FormData();
        formData.append("audio", recordingBlob);

        try {
          const response = await axios.post(
            `${SERVER_URL}/api/speech-to-text`,
            formData,
            {
              headers: {
                "Content-Type": "multipart/form-data",
              },
            }
          );
          console.log("Speech to text response:", response);
          questionLine = response.data.text
          answerLine = "Generating Your Answer"
          updateTextContent(questionLine,answerLine)
          await getChatGPTResponse({ transcript: response.data.text+ " use less than 7 sentence." });
        } catch (error) {
          console.log("error", error);
        }
      }

      const getChatGPTResponse = async ({ transcript }) => {
        console.log("Sending transcript to chat API:", transcript);
        updateText('Generating Answer');
        try {
          const response = await axios.post(`${SERVER_URL}/api/chat`, {
            message: transcript,
            voiceType: "alloy"
          });

          const answer = response.data.answer || "How can Ä± help you?";
          const answerAudio = response.data.audio;

          answerLine = answer
          updateTextContent(questionLine,answerLine)

          console.log("Chat API response:", response);
          console.log("Answer:", answer);

          // convert audio buffer to blob
          const buffer = new Uint8Array(answerAudio.data);
          const blob = new Blob([buffer], { type: "audio/mpeg" });
          const audioData = new File([blob], "answer.mp3", {
            type: "audio/mpeg",
          });

          // Create an audio element dynamically
          const audioElement = document.createElement('audio');
          audioElement.id = 'sound';
          document.body.appendChild(audioElement);
          audioElement.setAttribute('src', URL.createObjectURL(audioData));

          // Event listener for when audio playback ends
          audioElement.addEventListener('ended', () => {
            console.log('Audio playback ended');
            // Change visibility of the model
            const micBox = document.getElementById('micBox');
            const mutBox = document.getElementById('mutBox');
            if (micBox) {
              //updateText("Grab Mic To Talk")
              micBox.setAttribute('grabbable', '')
              playAnimation('Idle')
            }
          });
          updateText('Playing Answer');
          playAnimation('Talk')
          //playAnimation('Mouth')
          audioElement.play().catch(e => console.error('Error playing audio:', e));
          
          //const audioElement = document.getElementById("sound");

          //console.log(audioElement);
          //const loader = document.querySelector(".loader-container");
          //loader.style.display = "none";

          //audioElement.setAttribute("src",`url(${URL.createObjectURL(audioData)})`);
          //audioElement.play();
        } catch (error) {
          console.log("error", error);
        }
      };

      let stream, recorder;

      function updateText(newText) {
        /* var textEntity = document.querySelector('#dynamicText');
        textEntity.setAttribute('text', `value: ${newText}; align: center; width: 4`); */

      }

      async function handleStartRecording() {
        updateText("Release Mic To Stop Recording")
        //updateTabletText('Release Mic To Stop Recording');
        console.log("Starting recording...");
        stream = await navigator.mediaDevices.getUserMedia({
          video: false,
          audio: true,
        });

        recorder = new RecordRTCPromisesHandler(stream, {
          type: "audio",
        });

        recorder.startRecording();
      }



      AFRAME.registerComponent("anchor-grab-entity", {
          init: function () {
            console.log('anchor-grab-entity initialized on', this.el.id);

            this.el.addEventListener("grabstarted", this.deleteAnchor.bind(this));
            this.el.addEventListener("grabended", this.updateAnchor.bind(this));
          },

          updateAnchor: function (evt) {
            var grabbedEl = evt.detail.grabbedEl;
            console.log(grabbedEl)
            console.log("check")
            var anchoredComponent = grabbedEl.components.anchored;
            if (anchoredComponent) {
              anchoredComponent.createAnchor(
                grabbedEl.object3D.position,
                grabbedEl.object3D.quaternion
              );
            }
          },

          deleteAnchor: function (evt) {
            evt.preventDefault();
            var grabbedEl = evt.detail.grabbedEl;
            console.log(grabbedEl)
            var anchoredComponent = grabbedEl.components.anchored;
            if (anchoredComponent) {
              anchoredComponent.deleteAnchor();
            }
          },
        });

        
        AFRAME.registerComponent('hand-state-updater', {
         init: function () {
        this.el.addEventListener('grabstarted', () => {
            window.activeGrabbingHand = this.el;
        });
        this.el.addEventListener('grabended', () => {
            window.activeGrabbingHand = null;
        });
    }
});
        

      function playAnimation(clipName) {
        console.log("geldi",clipName)
        const model = document.getElementById('rigtestchar');
        const tempModel = document.getElementById('recordButton')
        console.log(tempModel)
        if(clipName == "talk"){
          model.setAttribute('animation-mixer', `clip: ${clipName}; loop: repeat; crossFadeDuration: 0.5`);
        }
        else{
          model.setAttribute('animation-mixer', `clip: ${clipName}; loop: repeat; crossFadeDuration: 0.5`);
        }
        
      }

      function stopAnimation() {
        const model = document.getElementById('apainting');
        model.setAttribute('animation-mixer', 'clip: *; timeScale: 0');
      }

      document.addEventListener('DOMContentLoaded', () => {
      const scene = document.querySelector('a-scene');
      if (!scene.hasLoaded) {
        scene.addEventListener('loaded', setupGrabListeners);
      } else {
        setupGrabListeners();
      }
    });

    function setupGrabListeners() {
      // Assuming 'planeTotal' is the ID of the entity you're interested in
      const planeTotal = document.getElementById('planeTotal');
      console.log("setup finished")

      // Replace 'grab-start' with the correct event name for your grabbing system
      planeTotal.addEventListener('grabstarted', (evt) => {
        console.log("grab done")
        if (!window.activeGrabbingHand) return;

        // Calculate and log the relative position
        calculateAndLogRelativePosition(planeTotal, window.activeGrabbingHand);
      });
    }

    function calculateAndLogRelativePosition(targetEl, handEl) {
      const handPositionWorld = new THREE.Vector3();
      handEl.object3D.getWorldPosition(handPositionWorld);

      const relativePosition = targetEl.object3D.worldToLocal(handPositionWorld.clone());
      console.log('Relative Position of Hand on planeTotal:', relativePosition);
    }

      document.addEventListener('DOMContentLoaded', () => {
      
        const grabbableElements = document.querySelectorAll('[anchor-grabbed-entity]');
        const recordButton = document.getElementById('recordButton');
        const micButton = document.getElementById('micBox')
        const mutButton = document.getElementById('mutBox')
        
        console.log('Initial RecordButton state:', recordButton.getAttribute('grabbable'));
      
        grabbableElements.forEach(el => {
          el.addEventListener('grabstarted', (evt) => {
            console.log(el)
            console.log(evt)
            const grabbedElement = evt.detail.grabbedEl; // Get the grabbed element
            console.log(grabbedElement.getAttribute('scale').x)
            console.log("Grab Started on element:", grabbedElement.id);
            console.log('Grabbable state:', evt.detail.grabbedEl.getAttribute('grabbable'));
            
            if(grabbedElement.id == "micBox"){
              if (!isRecordingInProgress) {
                updateText('Start Talking. Release Mic To Stop');
                console.log("Record Button grabbed");
                handleStartRecording().then(() => {
                  document.getElementById('mic').setAttribute('visible', false);
                  document.getElementById('micyellow').setAttribute('visible', true); // Change color on grab
                  isRecordingInProgress = true;
                });

              }
            }

            if(grabbedElement.id == "mutBox"){
              if(document.getElementById('r2d2model').getAttribute('visible') == true){
                console.log("geldi")
                document.getElementById('r2d2model').setAttribute('visible', false);
              }
              else{
                document.getElementById('r2d2model').setAttribute('visible', true);
              }
              
            }
          });

          el.addEventListener('grabended', (evt) => {
            const releasedElement = evt.detail.grabbedEl; // Get the released element
            console.log("Grab Ended on elements:", releasedElement.id);
            // Log the state of the grabbable component
            console.log('Grabbable state:', evt.detail.grabbedEl.getAttribute('grabbable'));
            //document.getElementById('mut').setAttribute('visible', true);

            if (releasedElement.id == "micBox" && isRecordingInProgress) {
              handleStopRecording().then(() => {
                isRecordingInProgress = false;
                releasedElement.removeAttribute('grabbable')
                document.getElementById('mic').setAttribute('visible', true); 
                document.getElementById('micyellow').setAttribute('visible', false); 
              });
            }
            if (releasedElement.id == "mutBox" && isRecordingInProgress) {
            
            }
          });
        });

        
        // Add click event for PC browser interactions
        mutButton.addEventListener('mousedown', (evt) => {
          if(document.getElementById('r2d2model').getAttribute('visible') == true){
                console.log("geldi")
                document.getElementById('r2d2model').setAttribute('visible', false);
              }
          else{
                document.getElementById('r2d2model').setAttribute('visible', true);
              }
              
        });

        // Add click event for PC browser interactions
        micButton.addEventListener('mousedown', (evt) => {
            console.log('mouse-down')
            const grabbedElement = evt.target; // Get the grabbed element
              if (!isRecordingInProgress) {
                updateText('Start Talking. Release Mic To Stop');
                console.log("Record Button grabbed");
                handleStartRecording().then(() => {
                  document.getElementById('mic').setAttribute('visible', false);
                  document.getElementById('micyellow').setAttribute('visible', true); // Change color on grab
                  isRecordingInProgress = true;
                });
            }
        });

        micButton.addEventListener('mouseup', (evt) => {
          console.log('mouse-up')
          handleStopRecording().then(() => {
                isRecordingInProgress = false;
                document.getElementById('mic').setAttribute('visible', true); 
                document.getElementById('micyellow').setAttribute('visible', false); 
              });
        });


        // Add touchstart event for mobile touch interactions
        micButton.addEventListener('touchstart', (evt) => {
          console.log('touch-started')
            const grabbedElement = evt.target; // Get the grabbed element
              if (!isRecordingInProgress) {
                updateText('Start Talking. Release Mic To Stop');
                console.log("Record Button grabbed");
                handleStartRecording().then(() => {
                  document.getElementById('mic').setAttribute('visible', false);
                  document.getElementById('micyellow').setAttribute('visible', true); // Change color on grab
                  isRecordingInProgress = true;
                });
            }

        });

      
        // Add touchstart event for mobile touch interactions
        micButton.addEventListener('touchended', (evt) => {
          console.log('touch-ended')
          handleStopRecording().then(() => {
                isRecordingInProgress = false;
                document.getElementById('mic').setAttribute('visible', true); 
                document.getElementById('micyellow').setAttribute('visible', false); 
              });
        });
      });


      async function handleStopRecording() {
        console.log("Stopping recording...");
        //const loader = document.querySelector(".loader-container");
        //loader.style.display = "flex";
        await recorder.stopRecording();
        let blob = await recorder.getBlob();
        stream.stop();
        console.log("send data to procesess aduio function", blob);
        updateText('Processing Your Sound');
        await processAudio(blob); 

        stream = null;
        recorder = null;
      }

      AFRAME.registerComponent('lock-position', {
    init: function () {
        // Store the initial position
        this.initialPosition = this.el.object3D.position.clone();
        this.initialRotation = this.el.object3D.rotation.clone();

        // Bind event listeners
        this.handleGrabStart = this.handleGrabStart.bind(this);
        this.el.addEventListener('grabstarted', this.handleGrabStart);
    },

    handleGrabStart: function () {
        console.log("debug")
        // Immediately reset the position when grab starts
        this.el.object3D.position.copy(this.initialPosition);
        this.el.object3D.rotation.copy(this.initialRotation);
    },

    tick: function () {
        // Continuously reset the position to the initial position
        this.el.object3D.position.copy(this.initialPosition);
        this.el.object3D.rotation.copy(this.initialRotation);
    },

    remove: function () {
        // Remove event listener when the component is removed
        console.log("debug")
        this.el.removeEventListener('grabended', this.handleGrabStart);
    }
});



      AFRAME.registerComponent('follow-button', {
        schema: {
          target: { type: 'selector' },
          xOffset: { type: 'number', default: 0 },
          yOffset: { type: 'number', default: 0 },
          zOffset: { type: 'number', default: 0 }
        },

        tick: function () {
          var target = this.data.target;
          if (target && target.object3D) {
            var targetPosition = target.object3D.position;
            var targetRotation = target.object3D.rotation;
            this.el.object3D.position.set(
              targetPosition.x + this.data.xOffset,
              targetPosition.y + this.data.yOffset,
              targetPosition.z + this.data.zOffset
            );
            this.el.object3D.rotation.set(

              this.el.object3D.rotation.x,
              targetRotation.y, // Keep original y rotation
              this.el.object3D.rotation.z
            );
          }
        }
      });

      AFRAME.registerComponent('follow-text', {
        schema: {
          target: { type: 'selector' },
          xOffset: { type: 'number', default: 0 },
          yOffset: { type: 'number', default: 0 },
          zOffset: { type: 'number', default: 0 }
        },

        tick: function () {
          var target = this.data.target;
          if (target && target.object3D) {
            var targetPosition = target.object3D.position;
            var targetRotation = target.object3D.rotation;
            this.el.object3D.position.set(
              targetPosition.x + this.data.xOffset,
              targetPosition.y + this.data.yOffset,
              targetPosition.z + this.data.zOffset
            );
            this.el.object3D.rotation.set(
              this.el.object3D.rotation.x,
              targetRotation.y, // Keep original y rotation
              this.el.object3D.rotation.z
            );
          }
        }
      });

      AFRAME.registerComponent('scale-watcher', {
        schema: {
    x: {type: 'number', default: 1},
    y: {type: 'number', default: 1},
    z: {type: 'number', default: 1}
  },

  init: function() {
    this.el.object3D.scale.set(this.data.x, this.data.y, this.data.z);
  },

  tick: function() {
    // Constantly reset the scale to the specified value
    this.el.object3D.scale.set(this.data.x, this.data.y, this.data.z);
  }
  });

  AFRAME.registerComponent('calculate-relative-position', {
    init: function () {
        // Assuming 'grab-start' is the event emitted when grabbing starts.
        // This might need to be adjusted based on your grab system.
        this.el.addEventListener('grabstarted', (evt) => {
            // Grabbing logic here

            // Calculate the relative position of the hand to 'planeTotal'
            const handPositionWorld = new THREE.Vector3(); // Placeholder for hand's world position
            // Assuming evt.detail.handEl exists and contains the hand entity.
            // You might need to adjust based on your actual event detail structure.
            evt.detail.handEl.object3D.getWorldPosition(handPositionWorld);

            const relativePosition = this.el.object3D.worldToLocal(handPositionWorld.clone());

            console.log('Relative Position of Hand on planeTotal:', relativePosition);
        });
    }
});

      

    /* AFRAME.registerComponent('hover', {
    init: function () {
      this.onCollisionStarted = this.onCollisionStarted.bind(this);
      this.onCollisionEnded = this.onCollisionEnded.bind(this);
      this.el.addEventListener('obbcollisionstarted', this.onCollisionStarted);
      this.el.addEventListener('obbcollisionended', this.onCollisionEnded);
    },

    onCollisionStarted: function (evt) {
        var withEl = evt.detail.withEl;
        if (!withEl.classList.contains('hoverable')) { return; }  // Only respond to hoverable entities
        console.log("Hover started on element:", withEl.id);
    },

    onCollisionEnded: function (evt) {
        var withEl = evt.detail.withEl;
        if (!withEl.classList.contains('hoverable')) { return; }  // Only respond to hoverable entities
        console.log("Hover ended on element:", withEl.id);
    }
  }); */
      
      function printModelTransformations(modelId) {
      const model = document.getElementById(modelId);

      if (model) {
          const position = model.object3D.position;
          const rotation = model.object3D.rotation;
          const scale = model.object3D.scale;

          console.log(`Position: x=${position.x}, y=${position.y}, z=${position.z}`);
          console.log(`Rotation: x=${rotation.x}, y=${rotation.y}, z=${rotation.z}`);
          console.log(`Scale: x=${scale.x}, y=${scale.y}, z=${scale.z}`);
      } else {
          console.log('Model not found');
      }
  }

  function updateTextContent(question, answer) {
    // Update question text
    const questionText = document.querySelector('#questionPlane a-text');
    questionText.setAttribute('value', question);
    fitTextToPlane(questionText, question);

    // Update answer text
    const answerText = document.querySelector('#answerPlane a-text');
    answerText.setAttribute('value', answer);
    fitTextToPlane(answerText, answer);
  }
  function fitTextToPlane(textEntity, text) {
    const planeWidth = parseFloat(textEntity.getAttribute('width'));
    const planeHeight = parseFloat(0.5);

    // Dynamic scaling factors based on text length
    const charWidthScaleFactor = calculateCharWidthScaleFactor(text.length);
    const lineHeight = calculateDynamicFactor(text.length, planeHeight, 'lineHeight');

    // Calculate wrap count based on dynamic scale factor
    const wrapCount = Math.max(Math.floor(planeWidth / charWidthScaleFactor), 1);
    // Estimate the number of lines the text might take up
    const estimatedLines = Math.ceil(text.length / wrapCount);

    // Calculate the maximum font size that fits within the plane height
    const maxFontSize = planeHeight / (estimatedLines * lineHeight);

    // Update the text entity attributes
    textEntity.setAttribute('text', {
        wrapCount: wrapCount,
        width: planeWidth,
        baseline: 'center',
        anchor: 'center',
        zOffset: 0.01,
        height: maxFontSize,
        value: text // Set the text content
    });
  }

  function calculateDynamicFactor(textLength, planeDimension, type) {
    // Define a base scale factor for your font and plane size
    const baseFactor = 0.0001;

    // Calculate a scaling ratio based on the text length
    const scaleRatio = textLength;
    console.log(textLength,planeDimension,type)
    console.log(scaleRatio)

    if (type === 'charWidth') {
        // Calculate character width scale factor
        return 0.04; // Adjust the multiplier as needed
    } else if (type === 'lineHeight') {
        // Calculate line height
        return scaleRatio; // Adjust the multiplier as needed
    } else {
        return baseFactor; // Default fallback
    }
  }

  function calculateCharWidthScaleFactor(textLength) {
      // Constants for the power-law formula
      // These would be determined by fitting your provided data points to a power-law relationship
      const A = 0.2; // This is a constant that adjusts the scale factor
      const B = -0.4; // This is the exponent in the power-law formula

      // Calculate the charWidthScaleFactor using a power-law relationship
      // charWidthScaleFactor = A * (textLength ^ B)
      // Note: Math.pow() is used to raise textLength to the power of B
      const charWidthScaleFactor = A * Math.pow(textLength, B);

      // Ensure the charWidthScaleFactor is within a reasonable range
      return Math.min(Math.max(charWidthScaleFactor, 0.015), 0.1);
  }


  function calculateMaxCharsPerLine(planeWidth, textEntity) {
    // Define the scale based on your specific font and desired sizing
    const charWidthScaleFactor = 0.01;
    return planeWidth / charWidthScaleFactor;
  }

  function calculateMaxFontSize(estimatedLines, planeHeight) {
    // Estimate the maximum font size to prevent vertical overflow
    const lineHeight = 0.01; // Line height based on the specific font's characteristics
    return Math.min(planeHeight / (estimatedLines * lineHeight), lineHeight);
  }
  // Example usage


    </script>
  </head>

  <body>
    <a-scene physics="driver: ammo" raycaster="objects: .clickable" obb-collider="showColliders: false" renderer="colorManagement: true;" button xr-mode-ui="XRMode: ar"
      info-message="htmlSrc: #messageText">
      <a-assets timeout="10000">
        <!-- Model by theGentleGiant https://sketchfab.com/3d-models/vintage-painting-dani-3fdd92904c2b44028bef28b33e897d9f -->
        <a-asset-item id="norigchar"
          src="https://cdn.glitch.global/b43aad67-87ae-4e45-8831-e783cd221e6f/norig-character.glb?v=1701273637085"
          response-type="arraybuffer" crossorigin="anonymous"></a-asset-item>
        <a-asset-item id="messageText" src="message.html"></a-asset-item>
      </a-assets>

      
     <!--  <a-assets timeout="10000">
        <a-asset-item id="mic"
          src="https://cdn.glitch.global/b43aad67-87ae-4e45-8831-e783cd221e6f/microphone.glb?v=1702047713741"
          response-type="arraybuffer" crossorigin="anonymous"></a-asset-item>
        <a-asset-item id="messageText2" src="message.html"></a-asset-item>
      </a-assets> -->

      <a-assets timeout="10000">
        <!-- Model by theGentleGiant https://sketchfab.com/3d-models/vintage-painting-dani-3fdd92904c2b44028bef28b33e897d9f -->
        <a-asset-item id="chartest"
          src="https://cdn.glitch.global/63f1eb40-f41e-4c89-ab7f-5b5f6294c036/chartest.glb?v=1705936570115"
          response-type="arraybuffer" crossorigin="anonymous"></a-asset-item>
        <a-asset-item id="messageText3" src="message.html"></a-asset-item>
      </a-assets>
      <a-assets timeout="10000">
        <!-- Model by theGentleGiant https://sketchfab.com/3d-models/vintage-painting-dani-3fdd92904c2b44028bef28b33e897d9f -->
        <a-asset-item id="rigtest"
          src="https://cdn.glitch.global/63f1eb40-f41e-4c89-ab7f-5b5f6294c036/c13.glb?v=1706010995927"
          response-type="arraybuffer" crossorigin="anonymous"></a-asset-item>
        <a-asset-item id="messageText3" src="message.html"></a-asset-item>
      </a-assets>
      <a-assets timeout="10000">
        <!-- Model by theGentleGiant https://sketchfab.com/3d-models/vintage-painting-dani-3fdd92904c2b44028bef28b33e897d9f -->
        <a-asset-item id="r2d2"
          src="https://cdn.glitch.global/63f1eb40-f41e-4c89-ab7f-5b5f6294c036/r2d2.glb?v=1709059010350"
          response-type="arraybuffer" crossorigin="anonymous"></a-asset-item>
        <a-asset-item id="messageText3" src="message.html"></a-asset-item>
      </a-assets>
<!-- 
      <a-assets timeout="10000">
        <a-asset-item id="arabicchar"
          src="https://cdn.glitch.global/63f1eb40-f41e-4c89-ab7f-5b5f6294c036/sauditest3.glb?v=1707916886600"
          response-type="arraybuffer" crossorigin="anonymous"></a-asset-item>
        <a-asset-item id="messageText3" src="message.html"></a-asset-item>
      </a-assets>
 -->

      <a-assets>
        <a-asset-item id="planeModel" src="https://cdn.glitch.global/63f1eb40-f41e-4c89-ab7f-5b5f6294c036/bgnew.glb?v=1709285249102"></a-asset-item>
    </a-assets>

    <a-assets timeout="10000">
      <!-- Model by theGentleGiant https://sketchfab.com/3d-models/vintage-painting-dani-3fdd92904c2b44028bef28b33e897d9f -->
      <a-asset-item id="micbutton"
        src="https://cdn.glitch.global/63f1eb40-f41e-4c89-ab7f-5b5f6294c036/newmic.glb?v=1709285267238"
        response-type="arraybuffer" crossorigin="anonymous"></a-asset-item>
      <a-asset-item id="messageText3" src="message.html"></a-asset-item>
    </a-assets>

    <a-assets timeout="10000">
      <!-- Model by theGentleGiant https://sketchfab.com/3d-models/vintage-painting-dani-3fdd92904c2b44028bef28b33e897d9f -->
      <a-asset-item id="micbuttonyellow"
        src="https://cdn.glitch.global/63f1eb40-f41e-4c89-ab7f-5b5f6294c036/butonbirsar%C4%B1.glb?v=1706872464079"
        response-type="arraybuffer" crossorigin="anonymous"></a-asset-item>
      <a-asset-item id="messageText3" src="message.html"></a-asset-item>
    </a-assets>

    <a-assets timeout="10000">
      <!-- Model by theGentleGiant https://sketchfab.com/3d-models/vintage-painting-dani-3fdd92904c2b44028bef28b33e897d9f -->
      <a-asset-item id="mutebutton"
        src="https://cdn.glitch.global/63f1eb40-f41e-4c89-ab7f-5b5f6294c036/robotplusicon.glb?v=1709285270429"
        response-type="arraybuffer" crossorigin="anonymous"></a-asset-item>
      <a-asset-item id="messageText3" src="message.html"></a-asset-item>
    </a-assets>

    <a-assets timeout="10000">
      <!-- Model by theGentleGiant https://sketchfab.com/3d-models/vintage-painting-dani-3fdd92904c2b44028bef28b33e897d9f -->
      <a-asset-item id="mutebuttonred"
        src="https://cdn.glitch.global/63f1eb40-f41e-4c89-ab7f-5b5f6294c036/butonikikirmizi.glb?v=1706872564711"
        response-type="arraybuffer" crossorigin="anonymous"></a-asset-item>
      <a-asset-item id="messageText3" src="message.html"></a-asset-item>
    </a-assets>

    <a-assets timeout="10000">
      <!-- Model by theGentleGiant https://sketchfab.com/3d-models/vintage-painting-dani-3fdd92904c2b44028bef28b33e897d9f -->
      <a-asset-item id="frame"
        src="https://cdn.glitch.global/63f1eb40-f41e-4c89-ab7f-5b5f6294c036/frame.glb?v=1706285277120"
        response-type="arraybuffer" crossorigin="anonymous"></a-asset-item>
      <a-asset-item id="messageText3" src="message.html"></a-asset-item>
    </a-assets>

    <a-assets timeout="10000">
      <!-- Model by theGentleGiant https://sketchfab.com/3d-models/vintage-painting-dani-3fdd92904c2b44028bef28b33e897d9f -->
      <a-asset-item id="frameandscreen"
        src="https://cdn.glitch.global/63f1eb40-f41e-4c89-ab7f-5b5f6294c036/frameandscreen.glb?v=1706285273756"
        response-type="arraybuffer" crossorigin="anonymous"></a-asset-item>
      <a-asset-item id="messageText3" src="message.html"></a-asset-item>
    </a-assets>

    <a-assets>
      <img id="my-image" src="https://cdn.glitch.global/63f1eb40-f41e-4c89-ab7f-5b5f6294c036/istanbul.webp?v=1706174762091">
  </a-assets>

      <!-- <a-entity id="tablet" position="0 1.5 -3" rotation="0 0 0" grabbable>
        <a-plane position="0 0 0" width="1" height="0.6" color="#FFF"></a-plane>
        <a-text id="questionText" position="0 0.2 0.01" text="align: center; width: 0.9" color="#000"></a-text>
        <a-text id="answerText" position="0 -0.2 0.01" text="align: center; width: 0.9" color="#000"></a-text>
    </a-entity> -->
    <a-box id="boundingBox" material="color: red; wireframe: true; opacity: 0.5" visible="false"></a-box>


      <a-entity id="recordButton" class="collidable" scale="1 1 1" position="0.45 1.3 -1.3" gltf-model="#mic"
         grabbable></a-entity>
        <a-entity id="rigtestchar" material="side: double" class="collidable" scale="1 1 1" position="0 0.7 -1.3" gltf-model="#rigtest"
        grabbable ></a-entity>
        <a-entity id="r2d2model" visible="false" material="side: double" class="collidable" scale="0.3 0.3 0.3" position="-1 0.7 -1.3" gltf-model="#r2d2"
        grabbable ></a-entity>
      <!-- <a-entity id="apainting" animation-mixer class="collidable" position="0 0.9 -17.5" gltf-model="#chartest"
        anchored="persistent: true" painting painting-changer grabbable rotation="0 0 0">
      </a-entity> -->
     <!--  <a-text id="dynamicText" class="ignore-ray" follow-text="target: #rigtestchar; xOffset: -0.25; yOffset: 1; zOffset: 1.3"
        text="value: Grab Mic To Talk; align: center; width: 4" position="0 1.9 0" color="#888"></a-text> -->
      <a-entity id="rightHand" hand-state-updater hand-tracking-grab-controls="hand: right" anchor-grabbed-entity collision-detector hover></a-entity>
      <a-entity id="leftHand" hand-state-updater hand-tracking-grab-controls="hand: left" anchor-grabbed-entity collision-detector hover></a-entity>
      <!-- Question Plane -->
    <!-- <a-entity grabbable id="questionPlane" position="0 1 0">
      <a-plane color="black" width="1.5" height="0.5"></a-plane>
      <a-text color="red" value="Your question here" wrap-count="20" width="1.5"></a-text>
  </a-entity>
  <a-entity grabbable id="answerPlane" position="0 0.5 0">
      <a-plane color="black" width="1.5" height="0.5"></a-plane>
      <a-text color="red" value="Your answer here" wrap-count="20" width="1.5"></a-text>
  </a-entity> -->
  <a-entity id="planeTotal" class="clickable" grabbable gltf-model="#planeModel" position="0 1.3 -0.8" scale="0.4 0.43 0.4" calculate-relative-position>
    <!-- Question Plane as a child entity -->
    <a-entity id="questionPlane" position="0.02 0.2 0" scale="0.8 0.5 1" >
        <a-plane material="color: blue; transparent: true; opacity: 0" width="1" height="0.5"></a-plane>
        <a-text value="Your question here" color="white" wrap-count="20" width="1"></a-text>
    </a-entity>

    <!-- Answer Plane as a child entity -->
    <a-entity id="answerPlane" position="0.02  0 0" scale="0.8 0.5 1">
        <a-plane material="color: blue; transparent: true; opacity: 1" width="0" height="0.5"></a-plane>
        <a-text value="Your answer here" color="white" wrap-count="20" width="1"></a-text>
    </a-entity>

    <a-box lock-position visible="false" id="micBox"  grabbable position="-0.23 -0.18 0" scale="0.1 0.18 0.1"></a-box>
    <a-entity id="mic" lock-position stationary-grab dynamic-body  gltf-model="#micbutton" position="-0.6 -0.32 0" scale="1 1 1"></a-entity>
    <a-entity id="micyellow" visible="false" lock-position stationary-grab dynamic-body  gltf-model="#micbuttonyellow" position="-0.6 -0.32 0" scale="1 1 1"></a-entity>
    <a-box lock-position visible="false" id="mutBox" position="0.19 -0.18 0" scale="0.2 0.18 0.1"></a-box>
    <a-entity id="mut" lock-position stationary-grab dynamic-body  gltf-model="#mutebutton" position="0.05 -0.32 0" scale="0.8 0.8 0.8"></a-entity>
    <a-entity id="mutred" visible="false" lock-position stationary-grab dynamic-body  gltf-model="#mutebuttonred" position="0.6 -0.32 0" scale="1 1 1"></a-entity>
  </a-entity>

  <a-entity id="framePlane" class="clickable" grabbable  position="1 1.3 -0.8" scale="1 1 1 ">
 
    <a-entity gltf-model="#frame"  position="0.05 0 0" scale="1 1 1" ></a-entity>
    <a-entity gltf-model="#frameandscreen" position="0.05 0 0" scale="1 1 1"></a-entity>
  </a-entity>
  
   <!--  <a-entity grabbable id="myImagePlane" position="1 1.3 -0.8"> 
        <a-plane material="src: #my-image" position="0 0 0" rotation="0 0 0" scale="0.5 0.5 0.5"></a-plane>
    </a-entity>   -->

      <a-entity>
        <a-camera id="camera" look-at="#planeTotal" wasd-controls-enabled="false">
          <a-entity id="cursor" cursor="rayOrigin: mouse; objects: .collidable" position="0 0 -1" visible="false"
            geometry="primitive: ring; radiusInner: 0.015; radiusOuter: 0.018" material="color: #888; shader: flat">
            <a-entity screen-touch />
          </a-entity>
        </a-camera>
        <!-- <a-camera id="camera" look-at="#rigtestchar" position="0 0.75 2" rotation="0 0 0" wasd-controls-enabled="false">
          <a-entity id="cursor" cursor="rayOrigin: mouse; objects: .collidable" position="0 0 -1" visible="false"
            geometry="primitive: ring; radiusInner: 0.015; radiusOuter: 0.018" material="color: #888; shader: flat">
            <a-entity screen-touch />
          </a-entity>
        </a-camera> -->
        <a-entity exit-ar-button></a-entity>
      </a-entity>
    </a-scene>
  </body>

  <script>
    // Replace 'yourModelId' with the actual ID of your model
      document.querySelector('a-scene').addEventListener('enter-vr', async () => {
      console.log("geldi")
      const scene = document.querySelector('a-scene');
      console.log("geldik")
      const session = scene.renderer.xr.getSession();

      let referenceSpace;
      console.log("test")
      try {
        referenceSpace = await session.requestReferenceSpace('bounded-floor');
        console.log(referenceSpace)
      } catch (e) {
        console.error('Could not get local-floor reference space:', e);
        return;
      }

      // Now you have a reference space that considers the floor level
      // You can use this to position your model
      const model = document.getElementById('apainting');
      //model.object3D.position.setY(0); // Assuming the model's origin is at its base
    });


    document.getElementById('rigtestchar').addEventListener('model-loaded', (e) => {
          const model = e.detail.model; // Get the loaded GLTF model
          var modelEntity = e.target
          console.log('Model loaded');

          const observer = new MutationObserver(mutations => {
            mutations.forEach(mutation => {
              console.log(mutation.attributeName)
              if (mutation.attributeName === 'scale') {
                console.log('Scale changed:', model.getAttribute('scale'));
              }
            });
          });

          observer.observe(modelEntity, { attributes: true });


          updateBoundingBox();
          
          console.log('Before scale set:', modelEntity.getAttribute('scale').x);
          modelEntity.setAttribute('scale', {x: 1, y: 1, z: 1});
          console.log('After scale set:', modelEntity.getAttribute('scale').x);
          

          if (model.animations && model.animations.length > 0) {
              console.log('Animation names:');
              model.animations.forEach((anim, index) => {
                  console.log(`${index}: ${anim.name}`);
              });
              playAnimation("Idle")
              //playAnimation("Mouth")
          } else {
              console.log('No animations found in the model');
          }
      });
  /*     function updateTextContent(question, answer) {
          const questionText = document.getElementById('questionText');
          const answerText = document.getElementById('answerText');

          // Function to dynamically adjust text size and wrapCount
          function adjustTextSizeAndPosition(text, isQuestion) {
              const baseSize = 0.9; // Base size for text width
              const scalingFactor = 0.0005; // Adjust this factor to control text scaling
              const size = Math.max(0.5, baseSize - text.length * scalingFactor);
              const wrapCount = Math.max(20, text.length / (size * 100));

              const yPosition = isQuestion ? 0.15 : -0.15; // Adjust Y position to minimize gap

              return { size, wrapCount, yPosition };
          }

          // Adjust properties for question and answer
          let questionProps = adjustTextSizeAndPosition(question, true);
          let answerProps = adjustTextSizeAndPosition(answer, false);

        // Update question text
          questionText.setAttribute('text', `value: Question: ${question}; align: center; width: ${questionProps.size}; wrapCount: ${questionProps.wrapCount}`);
          questionText.setAttribute('position', `0 ${questionProps.yPosition} 0.01`);

          // Update answer text
          answerText.setAttribute('text', `value: Answer: ${answer}; align: center; width: ${answerProps.size}; wrapCount: ${answerProps.wrapCount}`);
          answerText.setAttribute('position', `0 ${answerProps.yPosition} 0.01`);

      
      
      } */
      function updateBoundingBox() {
          console.log("gelmiyor")
          var modelEl = document.getElementById('rigtestchar');
          var bboxEl = document.getElementById('boundingBox');
          console.log("geldi")
          console.log(modelEl)
          console.log(modelEl.object3D.isVisible)

          // Ensure the model's object3D is available
          if (modelEl > 0) {
              var bbox = new THREE.Box3().setFromObject(modelEl.object3D);

              // Log the bounding box dimensions for debugging
              console.log('Bounding Box:', bbox.min, bbox.max);

              // Calculate the center and size of the bounding box
              var center = new THREE.Vector3();
              bbox.getCenter(center);
              var size = bbox.getSize(new THREE.Vector3());

              // Update the bounding box entity's position and scale
              bboxEl.object3D.position.set(center.x, center.y, center.z);
              bboxEl.setAttribute('geometry', {
                  primitive: 'box',
                  width: size.x,
                  height: size.y,
                  depth: size.z
              });
              bboxEl.setAttribute('visible', true);
          } else {
              console.log('Model object3D not available or no children');
          }
      }

          


    // Example usage
    const question = 'Your very long question text...Your very long question textYour very long question textYour very long question textYour very long question textYour very long question textYour very long question text...Your very long question textYour very long question textYour very long question textYour very long question textYour very long question textYour very long question text...Your very long question textYour very long question textYour very long question textYour very long question textYour very long question textYour very long question text...Your very long question textYour very long question textYour very long question textYour very long question textYour very long question textYour very long question text...Your very long question textYour very long question textYour very long question textYour very long question textYour very long question text';
    const answer = 'Your very long answer text...Your very long question textYour very long question textYour very long question textYour very long question textYour very long question text...Your very long question textYour very long question textYour very long question textYour very long question textYour very long question textYour very long question text...Your very long question textYour very long question textYour very long question textYour very long question textYour very long question textYour very long question text...Your very long question textYour very long question textYour very long question textYour very long question textYour very long question textYour very long question text...Your very long question textYour very long question textYour very long question textYour very long question textYour very long question textYour very long question text...Your very long question text...Your very long question textYour very long question textYour very long question textYour very long question textYour very long question textYour very long question text...Your very long question textYour very long question textYour very long question textYour very long question textYour very long question textYour very long question text...Your very long question textYour very long question textYour very long question textYour very long question textYour very long question textYour very long question text...Your very long question textYour very long question textYour very long question textYour very long question textYour very long question textYour very long question text...Your very long question textYour very long question textYour very long question textYour very long question textYour very long question text Your very long question textYour very long question textYour very long question textYour very long question textYour very long question text';
    updateTextContent(questionLine, answerLine);

    // Example usage:
    //updateTextContent("Short question text", "Longer answer text that needs to fit within the constraints of the plane without overflowing and maintaining a good visual appeal.");
    //updateContent(question, answer)
  </script>

  </html>